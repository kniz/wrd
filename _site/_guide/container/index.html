<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>container - namu</title>
<meta name="description" content="An amazing website.">


  <meta name="author" content="kniz">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="namu">
<meta property="og:title" content="container">
<meta property="og:url" content="http://localhost:4000/_guide/container/">


  <meta property="og:description" content="An amazing website.">











  

  


<link rel="canonical" href="http://localhost:4000/_guide/container/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "kniz",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="namu Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--page">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          namu
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/guide/">guide</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">about</a>
            </li><li class="masthead__menu-item">
              <a href="/play/">play</a>
            </li><li class="masthead__menu-item">
              <a href="/ref/">ref</a>
            </li><li class="masthead__menu-item">
              <a href="/posts/">news</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      <h1 id="container">container</h1>

<h2 id="array-map-tuple-3종류를-기본-제공한다">array, map, tuple 3종류를 기본 제공한다.</h2>

<h2 id="자바처럼-arraylist의-버금가는-활용도를-제공한다">자바처럼 arraylist의 버금가는 활용도를 제공한다.</h2>

<ul>
  <li>자바는 기본 배열은 어느순간 잘 안쓰게 되고 확장성 있는 arraylist를 사용을 자주한다.</li>
  <li>효율성을 버리고, 타입을 일원화하는데 초점을 맞춘다.</li>
</ul>

<h2 id="container는-생성자-문법이-통용되지-않는다">container는 생성자 문법이 통용되지 않는다.</h2>

<ul>
  <li>”[”, “]” 를 통해서 별도로 생성자처럼 사용한다.</li>
</ul>

<h2 id="container는-unique-object가-존재하지-않는다">container는 unique object가 존재하지 않는다.</h2>

<ul>
  <li>unique object에 접근하는 것처럼 문법을 작성하면 실제로는 텅빈 container를 만드는 것이다.</li>
  <li>container는 생성자가 없기 때문이다.</li>
</ul>

<h2 id="array">array</h2>

<h3 id="문법">문법</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[((value) (, value)*)*]
</code></pre></div></div>

<ul>
  <li>type deduction으로 값의 타입을 보고 어떠한 배열인지를 유추한다.</li>
  <li>텅빈 배열을 만들 수 있다.</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">:=</span> <span class="n">str</span><span class="p">[]</span> <span class="c">// arr is refer to str array.</span>
<span class="n">arr2</span> <span class="o">:=</span> <span class="n">str</span><span class="p">[]()</span> <span class="c">// empty arry to str.</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">arr2</span>
<span class="n">arr</span><span class="o">.</span><span class="nb">len</span> <span class="c">// 0</span>


<span class="n">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="s">"wow"</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">,</span> <span class="m">1</span><span class="p">]</span> <span class="c">// obj[]</span>
<span class="n">foo</span><span class="p">(</span><span class="n">strs</span> <span class="n">str</span><span class="p">[])</span> <span class="n">void</span>
    <span class="k">for</span> <span class="n">e</span> <span class="n">in</span> <span class="n">strs</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="n">foo</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="c">// err</span>
<span class="n">foo</span><span class="p">(</span><span class="n">arr</span> <span class="n">as</span> <span class="n">str</span><span class="p">[])</span> <span class="c">// casting err</span>

<span class="n">arr2</span> <span class="o">:=</span> <span class="n">str</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">e</span> <span class="n">in</span> <span class="n">arr</span>
    <span class="n">arr2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span> <span class="n">as</span> <span class="n">str</span><span class="p">)</span>
<span class="n">foo</span><span class="p">(</span><span class="n">arr2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="배열의-index는-0을-제외한-양수여야-한다">배열의 index는 0을 제외한 양수여야 한다.</h3>

<h3 id="add-del로-배열은-size가-고정되어-있지-않다">add, del로 배열은 size가 고정되어 있지 않다.</h3>

<h3 id="접근시-로-접근한다">접근시 []로 접근한다.</h3>

<ul>
  <li>arr[5]</li>
  <li>접근시 O(1)에 해당한다.</li>
</ul>

<h3 id="비어있는-원소가-없다">비어있는 원소가 없다.</h3>

<ul>
  <li>arr[2], arr[4]은 되지만 arr[3] 을 하면 exception 이 발생하거나 하진 않는다.</li>
  <li>물론 원소로써 null이 들어가 있을 수는 있다.</li>
</ul>

<h3 id="원소들은-모두-같은-타입이다">원소들은 모두 같은 타입이다.</h3>

<h3 id="배열을-범위를-벗어나면-runtime-에러가-발생하고-프로그램이-종료한다">배열을 범위를 벗어나면 runtime 에러가 발생하고 프로그램이 종료한다.</h3>

<h2 id="typelist">typelist</h2>

<ul>
  <li>typelist은 여러개의 서로 다른 타입들이 container로 존재하는 것이다.</li>
</ul>

<h3 id="문법-1">문법</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>((value) (, (value))*)*
</code></pre></div></div>

<h3 id="사실-사용자는-typelist을-마음껏-다룰-수-없다">사실 사용자는 typelist을 마음껏 다룰 수 없다.</h3>

<ul>
  <li>typelist을 정의하는 부분은 정해져 있다.
    <ul>
      <li>다중 할당 문법</li>
      <li>메소드의 인자리스트</li>
      <li>어떠한 문법의 일부</li>
    </ul>
  </li>
  <li>사실 , 로 여러개의 값 혹은 타입을 넘기거나 다루는 모든 것을 편의상 타입리스트이라고 하는 것 뿐이다.</li>
</ul>

<h3 id="typelist는-단독으로-있을-수-없다">typelist는 단독으로 있을 수 없다.</h3>

<ul>
  <li>계속 말하지만 정해진 위치에서만 사용이 가능하다.</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="m">1</span><span class="p">,</span> <span class="m">5</span> <span class="c">// 단독으로 있을 수 있다면, 이것은 마치 3개짜리 list로 보이기 시작한다.</span>
</code></pre></div></div>

<h3 id="멀티-반환값을-가진-메소드-정의하기">멀티 반환값을 가진 메소드 정의하기</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">def</span> <span class="n">app</span>
    <span class="n">foo</span><span class="p">()</span> <span class="kt">int</span><span class="p">,</span> <span class="n">float</span><span class="p">,</span> <span class="n">char</span> <span class="n">on</span> <span class="n">err</span> <span class="o">=&gt;</span>

    <span class="n">main</span><span class="p">()</span> <span class="n">void</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="n">on</span> <span class="n">res</span> <span class="o">:=</span> <span class="n">foo</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="sequence">sequence</h2>

<ul>
  <li>array의 일부 기능만 가지고 있는 제한된 컨테이너다.</li>
</ul>

<h3 id="문법-2">문법</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(include number) .. (include number)
</code></pre></div></div>

<ul>
  <li>예제
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">:=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span>
<span class="k">for</span> <span class="n">num</span> <span class="n">in</span> <span class="m">1.</span><span class="o">.</span><span class="n">arr</span><span class="o">.</span><span class="nb">len</span>
  <span class="n">sys</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="s">"$num,"</span><span class="p">)</span>
<span class="c">// 1,2,3,</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="원소마다-메모리를-점유하지-않는다">원소마다 메모리를 점유하지 않는다.</h3>

<h3 id="operator--를-지원하지-못한다">operator [, ]를 지원하지 못한다.</h3>

<ul>
  <li>대신 get(n)을 지원한다.</li>
  <li>operator[]를 지원하지 못하는 이유는 operator[]는 반환형E가 immutable이어도 mutable처럼 만들어주는 특이한 메소드이기 때문이다.
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ar</span> <span class="o">:=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">]</span>
<span class="n">ar</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="m">3</span> <span class="c">// int는 immutable이지만 3으로 변경되어야 한다.</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="seq-클래스가-이-문법을-구현한다">seq 클래스가 이 문법을 구현한다.</h3>

<h3 id="seq는-당연히-제네릭이다">seq는 당연히 제네릭이다.</h3>

<h3 id="seq는-그외에도-step을-받는-생성자들이-있다">seq는 그외에도 step을 받는 생성자들이 있다.</h3>

<ul>
  <li>직접 seq 객체를 생성하면 이 값을 채울 수 있다.</li>
  <li>seq도 반환할 수 있게 된다.</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span><span class="p">(</span><span class="n">s</span> <span class="kt">int</span><span class="p">,</span> <span class="n">e</span> <span class="kt">int</span><span class="p">,</span> <span class="n">s</span> <span class="n">step</span><span class="p">)</span> <span class="n">seq</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="c">// int만 step 이 있다.</span>
    <span class="k">return</span> <span class="n">seq</span><span class="o">&lt;</span><span class="n">str</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<span class="k">for</span> <span class="n">n</span> <span class="n">in</span> <span class="n">foo</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="o">-</span><span class="m">2</span><span class="p">)</span>
    <span class="o">.......</span>
</code></pre></div></div>

<h3 id="seq은-생성자-인자에-step이-없다">seq<str>은 생성자 인자에 step이 없다.</str></h3>

<h3 id="iterator를-내보낼-수-있어야-한다">iterator를 내보낼 수 있어야 한다.</h3>

<h3 id="haselem-e-bool를-지원한다">has(elem E) bool를 지원한다.</h3>

<h3 id="step이-얼마인지-start-end는-얼마인지-외부에서-seq객체로부터-알-수-있어야-한다">step이 얼마인지, start, end는 얼마인지 외부에서 seq객체로부터 알 수 있어야 한다.</h3>

<h3 id="ab에서-a가-더-작은-경우-reverse로-동작한다">a..b에서 a가 더 작은 경우 reverse로 동작한다.</h3>

<ul>
  <li>step은 항상 1 혹은 -1이다.</li>
</ul>

<h3 id="ab-문법은-seq의-인자-2개짜리-생성자를-부르는-syntactic-sugar다">a..b 문법은 seq의 인자 2개짜리 생성자를 부르는 syntactic sugar다.</h3>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sys</span><span class="o">.</span><span class="n">cons</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="s">"$4..2.step"</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="-문법은-반환형에-사용할-수-없다">”..” 문법은 반환형에 사용할 수 없다.</h3>

<ul>
  <li>반환형에는 값이 아니라 타입이 와야 한다.</li>
  <li>2..4 로 사용하면 이것은 타입이 아니라 값이다.</li>
  <li>반환하고 싶다면 seq를 사용하라.</li>
</ul>

<h2 id="pair">pair</h2>

<h3 id="문법-3">문법</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(value) : (value)
</code></pre></div></div>

<ul>
  <li>키와 값을 갖는 1개의 쌍이다.</li>
</ul>

<h3 id="key-val-로-각-member에-접근한다">key, val 로 각 member에 접근한다.</h3>

<p>arr := “name”: 3
arr.key
arr.member</p>

<h2 id="map">map</h2>

<ul>
  <li>hash다.</li>
</ul>

<h3 id="문법-4">문법</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[((pair) (, pair)*)*]
</code></pre></div></div>

<h3 id="element가-떨어진-배열-처럼-사용할-수-있다">element가 떨어진 배열 처럼 사용할 수 있다.</h3>

<h3 id="for-문에-넣으면-pair가-나온다">for 문에 넣으면 pair가 나온다.</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">map</span> <span class="o">:=</span> <span class="p">[</span><span class="s">"banana"</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span> <span class="s">"apple"</span><span class="o">:</span><span class="m">3</span><span class="p">]</span>

<span class="k">for</span> <span class="n">pair</span> <span class="n">in</span> <span class="k">map</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="s">"$pair.key:$pair.val"</span><span class="p">)</span>

<span class="k">for</span> <span class="n">v</span> <span class="n">in</span> <span class="k">map</span><span class="o">.</span><span class="n">vals</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="s">"value=$v"</span><span class="p">)</span>

<span class="k">map</span><span class="o">.</span><span class="n">keys</span>
</code></pre></div></div>

<h2 id="container-간-캐스팅은-container가-가진-타입-t에-대해서만-지원해야-한다">container 간 캐스팅은 container가 가진 타입 T에 대해서만 지원해야 한다.</h2>

<ul>
  <li>원소에 대해서 casting을 해서 변환을 하면 안된다.</li>
  <li>그것은 캐스팅이 아니라 변환(conversion)에 해당한다.</li>
</ul>

<h2 id="복잡한-컨테이너-문법">복잡한 컨테이너 문법</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">def</span> <span class="n">app</span> <span class="n">commonMyApp</span>
    <span class="n">res</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="n">arr</span> <span class="kt">int</span><span class="p">[],</span> <span class="n">cache</span> <span class="n">base</span><span class="p">[</span><span class="n">str</span><span class="p">],</span> <span class="n">key</span> <span class="n">str</span><span class="p">)</span> <span class="kt">int</span><span class="p">[][</span><span class="n">str</span><span class="p">],</span> <span class="n">base</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="n">on</span> <span class="n">err</span>
        <span class="k">return</span> <span class="kt">int</span><span class="p">[][</span><span class="n">str</span><span class="p">](),</span> <span class="n">base</span><span class="p">[</span><span class="n">str</span><span class="p">]()</span> <span class="n">on</span> <span class="n">myErr</span>

    <span class="n">main</span><span class="p">()</span> <span class="n">void</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">on</span> <span class="n">res</span> <span class="o">:=</span> <span class="n">foo</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">null</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">age</span> <span class="o">:=</span> <span class="n">a</span><span class="p">[</span><span class="s">"wow"</span><span class="p">][</span><span class="m">3</span><span class="p">]</span>
        <span class="n">baseWas</span> <span class="o">:=</span> <span class="n">b</span><span class="p">[</span><span class="s">"wow"</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="chain">chain</h2>

<ul>
  <li>native에서만 사용하는 container다.</li>
  <li>다른 알고리즘이나 container를 대신 사용해도 무방하다.</li>
  <li>배열1과 배열2가 있을때 이 둘을 chain해서 배열1의 원소와  배열2의 원소를 모두 가진것처럼 보이는 배열을 만들수 있어야 한다.</li>
  <li>List건, vector건 모든 컨테이너에 적용되야 한다.</li>
</ul>

<h2 id="container는-known-worldlang-class-이다">container는 known worldlang class 이다.</h2>
<ul>
  <li>순수 c++ 로 작성된 것은 native영역에만 존재하거나 극히 일부분의 managed 영역 객체에 한한다.</li>
  <li>managed 영역에 실재하게 되는 인스턴스가 순수 c++로 작성되는 것을 최대한 피한다.</li>
  <li>managed 영역에 존재하게 하는 가장 확실한 방법은 world언어로 작성하여 pack로 import 시키는 방법이다.</li>
  <li>이 방법에서 벗어나서 managed 영역에 존재한다는 것은 예외적인 상황을 의미하므로 이러한 상황을 피하는 것이다.</li>
  <li>container 또한 별도의 world언어로 작성된 pack로써 import되어 시스템에 들어간다.</li>
  <li>그러나 interpreter는 특정 문법이 동작하려면 container의 존재를 알 수 있어야 하며, node가 container 인지 아닌지 등을 알 수 있어야 한다.</li>
  <li>그러므로 predefined library로써 프로그램 파싱전에 반드시 import 된다는 걸 언어 스펙으로써 보장한다.</li>
  <li>unique한 string을 주어졌을때 이걸로부터 특정 클래스의 TMeta를 접근할 수 있는 방법이 제공된다.
    <ul>
      <li>이 방법은 어디서건 어느때에건 호출 할 수 있어야 한다.</li>
      <li>interpreter는 이걸 사용해서 container의 meta클래스를 얻어올 수 있다.</li>
      <li>interpreter는 이걸 사용해서 container의 객체를 생성하거나 상속관계를 verify 할 수 있게 된다.</li>
    </ul>
  </li>
  <li>이 string은 alltime unique해야 하며, 로케일, 지역, 언어, 재부팅, 시간변경, 단말 변경에 관계없이 동일한 unique 한 값을 정의할 수 있어야 한다.</li>
</ul>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 kniz. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
