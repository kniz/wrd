<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>world-doc: scope</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">world-doc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">scope </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>scope은 개념적으로 3종류로 분류한다.</h1>
<ul>
<li>object scope 은 객체 1개에 대한 멤버들이 등록된다.<ul>
<li>world에서는 가장 바깥 공간에 pack 객체가 있다. pack 또한 obj 이므로 전역공간이 별도로 존재하지 않는다.</li>
</ul>
</li>
<li>local scope 은 메소드 실행 도중에 발생하는 객체들이 등록된다.</li>
</ul>
<h1>그러나 구현에서는 영역을 구분하지 않고 frame안의 1개의 chain에 몽땅 넣는다.</h1>
<ul>
<li>따라서 frame에 들어가는 scope의 순서가 중요하다.</li>
<li>pack 넣고, filescope 넣고, obj넣고, localscopes 넣는다.</li>
</ul>
<h1>모든 메소드는 실행하기 전에 넘겨받은 thisobj 로 scope을 갱신하려고 한다.</h1>
<h1>객체는 자신의 object scope을 교체하고 localscope을 비운다.</h1>
<h1>interpret 과정은 origin 객체의 generation 과 bind&amp;verify 가 별도의 phase로 구성되어 있다.</h1>
<ul>
<li>따라서 객체의 메소드를 정의할때 안에 구현에서 아직 나오지 않은 다른 origin객체나 메소드를 사용하더라도 문제가 없다.</li>
<li>메소드의 localscope은 런타임에 생성되니 제외한다.</li>
</ul>
<h1>this</h1>
<ul>
<li>objscope에 접근하는 키워드다.</li>
<li>기본적으로 scope에 들어가 있다. this는 이름 충돌시에 사용한다.</li>
</ul>
<h1>scope와 이름충돌</h1>
<ul>
<li>개념적으로 본다면 동일한 레벨의 indentation 내에 같은 심볼이 있으면 컴파일 에러로 판단한다.</li>
<li>이를 구현하는 방법은 frame에 담긴 element가 가진 name과 args 가 중복되면 에러로 판단하는 것이다.<ul>
<li>이 검사는 verify 단계에서만 실시한다.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">def sample</div>
<div class="line">    foo(n int) void</div>
<div class="line">        foo := 5 // ok</div>
<div class="line">        aka foo -&gt; boo // ok</div>
<div class="line">        aka foo -&gt; koo // ok</div>
<div class="line">        aka foo -&gt; foo // err. &#39;foo&#39; is on same scope, local scope, already.</div>
<div class="line">            with boo</div>
<div class="line">            n := it++ // err. n is on local scope. duplicated.</div>
<div class="line">            $n := it // err. static n var is on local scope too.</div>
<div class="line">            aka $b := it -&gt; n // err. &#39;n&#39; is on local scope already.</div>
</div><!-- fragment --><h1>하나의 scope에 복수의 subs()가 할당되어야 하는 경우에는 ndeepChain을 넣는다.</h1>
<ul>
<li>frame은 1개의 chain만 갖는다.</li>
<li>이름 충돌 rule에 의해서 frame(== chain)의 각 container가 중복체크를 하는 단위가 된다.</li>
<li>각 container가 indentation level을 표현하는 것이며 안에만 동일한 name + args 가 없으면 중복을 피하게 된다.</li>
<li>이 frame에 scope을 넣을때 scope에 여러 container를 한 묶음으로 할당해야 하는 경우가 생긴다.<ul>
<li>e.g. 상속을 하지 않는 객체의 subs()는 2개의 container가 chain으로 묶여있을 것이다.</li>
<li>그러나 이 2개가 frame에 들어갈때는 한 묶음으로 들어가야 한다.</li>
<li>이경우 ndeepChain(subs()) 로 묶어서 ndeepChain 한개만 frame에 add한다.</li>
<li>e.g. A객체가 B로부터 상속한 경우, A와 B는 개념적으로 같은 이름을 가질 수 있다.</li>
<li>따라서 frame에 들어갈때는 각 container가 shallow cpy 되서 들어간다.</li>
</ul>
</li>
</ul>
<h1>func는 이름만 같을 뿐 아니라 인자리스트까지도 같아야 같은 충돌로 간주한다.</h1>
<ul>
<li>반환형은 제외한다.</li>
</ul>
<h1>with</h1>
<div class="fragment"><div class="line">&lt;indent&gt;</div>
<div class="line">    with &lt;identifier&gt; (, &lt;identifier&gt;)*</div>
<div class="line"> </div>
<div class="line">    [&lt;expr&gt;]*</div>
<div class="line">&lt;dedent&gt;</div>
</div><!-- fragment --><ul>
<li>식별자가 있는 경우 블록문을 실행하는 동안 식별자의 scope을 현재 scope보다 상위로 chain에 push 한다.</li>
<li>with가 사용된 scope이 어디냐에 따라서 구현이 살짝 달라진다.</li>
</ul>
<h1>with는 항상 사용된 indent level의 최 상단에 놓여져야 한다.</h1>
<h1>with가 어디에 사용되었느냐에 따라 구현이 다르다.</h1>
<ul>
<li>filescope에서 사용된 경우 filescope에 추가된다.<ul>
<li>filescope에 with의 내용을 추가한 후 pack을 가리키도록 한다.</li>
</ul>
</li>
<li>with가 메소드 안에 사용된 경우는 withBlockExpr 이라는 별도의 객체로 정의한다.<ul>
<li>해당 객체는 새로운 array를 생성해 localscope에 add하기 직전에 with를 실행해서 가져온 객체의 subs()도 하나의 array로 묶는다.</li>
</ul>
</li>
</ul>
<h1>scope는 chain을 reversed 하게 구성한다.</h1>
<ul>
<li>reversed 하게 chain을 엮으면 stack처럼 사용할 수 있기 때문이다.<ul>
<li>reversed라는 것은 chain의 head가 항상 최근에 넣은 container를 가리키게 한다는 것이다.</li>
</ul>
</li>
<li>scope는 STACK (FILO) 메카니즘을 가지므로 scope의 추가와 삭제가 다음과 같이 된다.</li>
</ul>
<div class="fragment"><div class="line">// 추가:</div>
<div class="line">newChain.link(scope.head)</div>
<div class="line">scope.head.bind(newChain)</div>
<div class="line"> </div>
<div class="line">// 삭제:</div>
<div class="line">scope.head.bind(scope.head.next)</div>
</div><!-- fragment --><ul>
<li>게다가 head부터 탐색해가므로 localscope부터 순차탐색하게 되는데, 이것은 언어spec에서 가장 indentlv 이 깊은 symbol이 먼저 택해진다는 규칙과 잘 맞는다.</li>
</ul>
<h1>같은 pack 내에서의 객체들은 서로 with를 하지 않아도 된다.</h1>
<ul>
<li>같은 pack scope에 있으니까.</li>
</ul>
<h1>with는 와일드 카드를 지원하지 않는다.</h1>
<h1>with는 콤마를 지원한다.</h1>
<h1>with가 import를 대신한다.</h1>
<div class="fragment"><div class="line">// mymodule:</div>
<div class="line">def person()</div>
<div class="line">    foo() void</div>
<div class="line">        print(&#39;hello world!&#39;)</div>
<div class="line"> </div>
<div class="line">main() void</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">// app.namu:</div>
<div class="line">mymodule.person.foo() // ok</div>
<div class="line"> </div>
<div class="line">with mymodule</div>
<div class="line">person.foo() // ok</div>
</div><!-- fragment --><h1>블록문은 indentation으로 표현한다.</h1>
<div class="fragment"><div class="line">b := foo()</div>
<div class="line">    a := koo()</div>
<div class="line">    a.doSomething() // &#39;a&#39; destoryed</div>
<div class="line">print(b)</div>
</div><!-- fragment --><h1>블록문에 with를 한경우 해당 블록문에만 with가 적용된다.</h1>
<ul>
<li>with는 현재 최상단 scope에만 영향을 주기 때문이다.</li>
</ul>
<h1>with 는 statement 다.</h1>
<div class="fragment"><div class="line">if (b := foo()) &gt; 2</div>
<div class="line">    with b, c := koo()</div>
<div class="line">    // (with b) + 5 -&gt; err</div>
<div class="line">    // with b + 5 -&gt; err</div>
</div><!-- fragment --><h1>메소드 안에서 임시 생성하는 모든 것들은 local scope이다.</h1>
<ul>
<li>메소드의 parameter list</li>
<li>반환값</li>
<li>메소드 실행중 생성되는 local 변수</li>
</ul>
<h1>node 기본적으로 sub를 접근할 수 있는 다음 API를 제공한다.</h1>
<ul>
<li>식별자명, 타입과 인자리스트를 모두 받는 것이 원본 API가 된다. <div class="fragment"><div class="line">// 정상이면 ret.val로 접근, 2개 이상 hit하면 ret.err에 hit한 sub가 모두 들어있다.</div>
<div class="line">get&lt;T=node&gt;(name str, types Type[]) ret&lt;ref&gt;</div>
<div class="line">get&lt;T=node&gt;(name str, type Type...) ret&lt;ref&gt;</div>
<div class="line">gets(name str) ret&lt;ref[]&gt;</div>
</div><!-- fragment --></li>
</ul>
<h1>sub를 찾을때 null일 인자를 넣는것과, 빈 인자리스트를 넣는 것은 다르다.</h1>
<div class="fragment"><div class="line">get(&quot;anyName&quot;) // anyName인 객체를 찾는 것이다.</div>
<div class="line">get(&quot;anyName&quot;, {}) // anyName() 를 찾는 것이다.</div>
</div><!-- fragment --><h1>블록문 내의 변수의 scope는 항상 indent depth에 의해 판단된다.</h1>
<ul>
<li>다른 언어에 비해 expression 기반인 namu 는 변수의 scope을 생소한 케이스가 몇개 있다.</li>
</ul>
<div class="fragment"><div class="line">if val := foo()</div>
<div class="line">    val++</div>
<div class="line">print(val)</div>
</div><!-- fragment --><ul>
<li>val은 if 문 내에서 정의되었지만 indent level은 print(val) 구문과 동일하다.</li>
<li>따라서 if 블록문 밖에서도 접근이 가능하다.</li>
</ul>
<div class="fragment"><div class="line">for n in arr</div>
<div class="line">    print(n)</div>
<div class="line">print(&quot;finally n was $n&quot;)</div>
</div><!-- fragment --><ul>
<li>마찬가지로 foo 문 내에서 정의된 n은 for 문 바깥에서도 접근이 가능하다.</li>
<li>따라서 다음과 같은 코드는 에러다.</li>
</ul>
<div class="fragment"><div class="line">for n in arr</div>
<div class="line">    print(n)</div>
<div class="line"> </div>
<div class="line">//for n in arr2 // err: n은 이미 정의한 적이 있다.</div>
<div class="line">//    print(n)</div>
<div class="line"> </div>
<div class="line">for n2 in arr2 // ok</div>
<div class="line">    print(n)</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
