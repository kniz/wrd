<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>world-doc: container</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">world-doc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">container </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>array, map, tuple 3종류를 기본 제공한다.</h1>
<h1>자바처럼 arraylist의 버금가는 활용도를 제공한다.</h1>
<ul>
<li>자바는 기본 배열은 어느순간 잘 안쓰게 되고 확장성 있는 arraylist를 사용을 자주한다.</li>
<li>효율성을 버리고, 타입을 일원화하는데 초점을 맞춘다.</li>
</ul>
<h1>container는 생성자 문법이 통용되지 않는다.</h1>
<ul>
<li>"[", "]" 를 통해서 별도로 생성자처럼 사용한다.</li>
</ul>
<h1>container는 unique object가 존재하지 않는다.</h1>
<ul>
<li>unique object에 접근하는 것처럼 문법을 작성하면 실제로는 텅빈 container를 만드는 것이다.</li>
<li>container는 생성자가 없기 때문이다.</li>
</ul>
<h1>array</h1>
<h2>문법</h2>
<pre class="fragment">[((value) (, value)*)*]
</pre><ul>
<li>type deduction으로 값의 타입을 보고 어떠한 배열인지를 유추한다.</li>
<li>텅빈 배열을 만들 수 있다.</li>
</ul>
<div class="fragment"><div class="line">arr := str[] // arr is refer to str array.</div>
<div class="line">arr2 := str[]() // empty arry to str.</div>
<div class="line">arr = arr2</div>
<div class="line">arr.len // 0</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">arr := [&quot;wow&quot;, &quot;hello&quot;, 1] // obj[]</div>
<div class="line">foo(strs str[]) void</div>
<div class="line">    for e in strs</div>
<div class="line">        sys.out(e)</div>
<div class="line">foo(arr) // err</div>
<div class="line">foo(arr as str[]) // casting err</div>
<div class="line"> </div>
<div class="line">arr2 := str[]</div>
<div class="line">for e in arr</div>
<div class="line">    arr2.add(e as str)</div>
<div class="line">foo(arr2)</div>
</div><!-- fragment --><h2>배열의 index는 0을 제외한 양수여야 한다.</h2>
<h2>add, del로 배열은 size가 고정되어 있지 않다.</h2>
<h2>접근시 []로 접근한다.</h2>
<ul>
<li>arr[5]</li>
<li>접근시 O(1)에 해당한다.</li>
</ul>
<h2>비어있는 원소가 없다.</h2>
<ul>
<li>arr[2], arr[4]은 되지만 arr[3] 을 하면 exception 이 발생하거나 하진 않는다.</li>
<li>물론 원소로써 null이 들어가 있을 수는 있다.</li>
</ul>
<h2>원소들은 모두 같은 타입이다.</h2>
<h2>배열을 범위를 벗어나면 runtime 에러가 발생하고 프로그램이 종료한다.</h2>
<h1>typelist</h1>
<ul>
<li>typelist은 여러개의 서로 다른 타입들이 container로 존재하는 것이다.</li>
</ul>
<h2>문법</h2>
<pre class="fragment">((value) (, (value))*)*
</pre><h2>사실 사용자는 typelist을 마음껏 다룰 수 없다.</h2>
<ul>
<li>typelist을 정의하는 부분은 정해져 있다.<ul>
<li>다중 할당 문법</li>
<li>메소드의 인자리스트</li>
<li>어떠한 문법의 일부</li>
</ul>
</li>
<li>사실 , 로 여러개의 값 혹은 타입을 넘기거나 다루는 모든 것을 편의상 타입리스트이라고 하는 것 뿐이다.</li>
</ul>
<h2>typelist는 단독으로 있을 수 없다.</h2>
<ul>
<li>계속 말하지만 정해진 위치에서만 사용이 가능하다.</li>
</ul>
<div class="fragment"><div class="line">b, c := 1, 5 // 단독으로 있을 수 있다면, 이것은 마치 3개짜리 list로 보이기 시작한다.</div>
</div><!-- fragment --><h2>멀티 반환값을 가진 메소드 정의하기</h2>
<div class="fragment"><div class="line">def app</div>
<div class="line">    foo() int, float, char on err =&gt;</div>
<div class="line"> </div>
<div class="line">    main() void</div>
<div class="line">        a, b, c on res := foo()</div>
</div><!-- fragment --><h1>sequence</h1>
<ul>
<li>array의 일부 기능만 가지고 있는 제한된 컨테이너다.</li>
</ul>
<h2>문법</h2>
<pre class="fragment">(include number) .. (include number)
</pre><ul>
<li>예제 <div class="fragment"><div class="line">arr := [1, 2, 3]</div>
<div class="line">for num in 1..arr.len</div>
<div class="line">    sys.out(&quot;$num,&quot;)</div>
<div class="line">// 1,2,3,</div>
</div><!-- fragment --></li>
</ul>
<h2>원소마다 메모리를 점유하지 않는다.</h2>
<h2>operator [, ]를 지원하지 못한다.</h2>
<ul>
<li>대신 get(n)을 지원한다.</li>
<li>operator[]를 지원하지 못하는 이유는 operator[]는 반환형E가 immutable이어도 mutable처럼 만들어주는 특이한 메소드이기 때문이다. <div class="fragment"><div class="line">ar := [1, 2]</div>
<div class="line">ar[0] = 3 // int는 immutable이지만 3으로 변경되어야 한다.</div>
</div><!-- fragment --></li>
</ul>
<h2>seq 클래스가 이 문법을 구현한다.</h2>
<h2>seq는 당연히 제네릭이다.</h2>
<h2>seq는 그외에도 step을 받는 생성자들이 있다.</h2>
<ul>
<li>직접 seq 객체를 생성하면 이 값을 채울 수 있다.</li>
<li>seq도 반환할 수 있게 된다.</li>
</ul>
<div class="fragment"><div class="line">foo(s int, e int, s step) seq&lt;int&gt; // int만 step 이 있다.</div>
<div class="line">    return seq&lt;str&gt;(s, e, s)</div>
<div class="line"> </div>
<div class="line">for n in foo(5, 1, -2)</div>
<div class="line">    .......</div>
</div><!-- fragment --><h2>seq&lt;str&gt;은 생성자 인자에 step이 없다.</h2>
<h2>iterator를 내보낼 수 있어야 한다.</h2>
<h2>has(elem E) bool를 지원한다.</h2>
<h2>step이 얼마인지, start, end는 얼마인지 외부에서 seq객체로부터 알 수 있어야 한다.</h2>
<h2>a..b에서 a가 더 작은 경우 reverse로 동작한다.</h2>
<ul>
<li>step은 항상 1 혹은 -1이다.</li>
</ul>
<h2>a..b 문법은 seq의 인자 2개짜리 생성자를 부르는 syntactic sugar다.</h2>
<div class="fragment"><div class="line">sys.cons.out(&quot;$4..2.step&quot;)</div>
</div><!-- fragment --><h2>".." 문법은 반환형에 사용할 수 없다.</h2>
<ul>
<li>반환형에는 값이 아니라 타입이 와야 한다.</li>
<li>2..4 로 사용하면 이것은 타입이 아니라 값이다.</li>
<li>반환하고 싶다면 seq를 사용하라.</li>
</ul>
<h1>pair</h1>
<h2>문법</h2>
<pre class="fragment">(value) : (value)
</pre><ul>
<li>키와 값을 갖는 1개의 쌍이다.</li>
</ul>
<h2>key, val 로 각 member에 접근한다.</h2>
<p>arr := "name": 3 arr.key arr.member</p>
<h1>map</h1>
<ul>
<li>hash다.</li>
</ul>
<h2>문법</h2>
<pre class="fragment">[((pair) (, pair)*)*]
</pre><h2>element가 떨어진 배열 처럼 사용할 수 있다.</h2>
<h2>for 문에 넣으면 pair가 나온다.</h2>
<div class="fragment"><div class="line">map := [&quot;banana&quot;: 1, &quot;apple&quot;:3]</div>
<div class="line"> </div>
<div class="line">for pair in map</div>
<div class="line">    sys.out(&quot;$pair.key:$pair.val&quot;)</div>
<div class="line"> </div>
<div class="line">for v in map.vals</div>
<div class="line">    sys.out(&quot;value=$v&quot;)</div>
<div class="line"> </div>
<div class="line">map.keys</div>
</div><!-- fragment --><h1>container 간 캐스팅은 container가 가진 타입 T에 대해서만 지원해야 한다.</h1>
<ul>
<li>원소에 대해서 casting을 해서 변환을 하면 안된다.</li>
<li>그것은 캐스팅이 아니라 변환(conversion)에 해당한다.</li>
</ul>
<h1>복잡한 컨테이너 문법</h1>
<div class="fragment"><div class="line">def app commonMyApp</div>
<div class="line">    res, res2 =&gt; foo(arr int[], cache base[str], key str) int[][str], base[str] on err</div>
<div class="line">        return int[][str](), base[str]() on myErr</div>
<div class="line"> </div>
<div class="line">    main() void</div>
<div class="line">        if a, b on res := foo(null, null, null)</div>
<div class="line">            return</div>
<div class="line"> </div>
<div class="line">        age := a[&quot;wow&quot;][3]</div>
<div class="line">        baseWas := b[&quot;wow&quot;]</div>
</div><!-- fragment --><h1>chain</h1>
<ul>
<li>native에서만 사용하는 container다.</li>
<li>다른 알고리즘이나 container를 대신 사용해도 무방하다.</li>
<li>배열1과 배열2가 있을때 이 둘을 chain해서 배열1의 원소와 배열2의 원소를 모두 가진것처럼 보이는 배열을 만들수 있어야 한다.</li>
<li>List건, vector건 모든 컨테이너에 적용되야 한다.</li>
</ul>
<h1>container는 known worldlang class 이다.</h1>
<ul>
<li>순수 c++ 로 작성된 것은 native영역에만 존재하거나 극히 일부분의 managed 영역 객체에 한한다.</li>
<li>managed 영역에 실재하게 되는 인스턴스가 순수 c++로 작성되는 것을 최대한 피한다.</li>
<li>managed 영역에 존재하게 하는 가장 확실한 방법은 world언어로 작성하여 pack로 import 시키는 방법이다.</li>
<li>이 방법에서 벗어나서 managed 영역에 존재한다는 것은 예외적인 상황을 의미하므로 이러한 상황을 피하는 것이다.</li>
<li>container 또한 별도의 world언어로 작성된 pack로써 import되어 시스템에 들어간다.</li>
<li>그러나 interpreter는 특정 문법이 동작하려면 container의 존재를 알 수 있어야 하며, node가 container 인지 아닌지 등을 알 수 있어야 한다.</li>
<li>그러므로 predefined library로써 프로그램 파싱전에 반드시 import 된다는 걸 언어 스펙으로써 보장한다.</li>
<li>unique한 string을 주어졌을때 이걸로부터 특정 클래스의 TMeta를 접근할 수 있는 방법이 제공된다.<ul>
<li>이 방법은 어디서건 어느때에건 호출 할 수 있어야 한다.</li>
<li>interpreter는 이걸 사용해서 container의 meta클래스를 얻어올 수 있다.</li>
<li>interpreter는 이걸 사용해서 container의 객체를 생성하거나 상속관계를 verify 할 수 있게 된다.</li>
</ul>
</li>
<li>이 string은 alltime unique해야 하며, 로케일, 지역, 언어, 재부팅, 시간변경, 단말 변경에 관계없이 동일한 unique 한 값을 정의할 수 있어야 한다. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
