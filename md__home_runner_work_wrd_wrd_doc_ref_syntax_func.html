<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>world-doc: func</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">world-doc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">func </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Func는 일반 객체와 다른, 확장이 불가능한 builtin 객체다.</h1>
<ul>
<li>메소드 또한 객체로써 취급한다. 그러나 일반 객체와는 다음과 같은 항목에서 다르다.<ul>
<li>그러나 메소드의 메소드는 고정된 항목들이며 메소드로부터 확장하거나 extend가 불가능하다.</li>
<li>메소드가 제공하는 메소드는 RTTI 관련 항목이다.</li>
<li>메소드는 Object가 아니므로 객체마다의 멤버는 가질 수 없으나 공유멤버는 가질 수 있다.</li>
</ul>
</li>
<li>다음은 일반 객체와의 공통점이다.<ul>
<li>메소드는 객체이므로 메소드에 대한 참조를 만들 수 있다.</li>
<li>메소드는 블록문을 가지고 있다.</li>
<li>메소드의 정의는 expr 으로 취급한다.</li>
</ul>
</li>
</ul>
<h1>모든 메소드는 객체에 속해있다.</h1>
<ul>
<li>static 클래스는 존재하지 않는다. static 메소드 역시 존재하지 않는다.</li>
<li>static 변수는 존재한다.</li>
<li>메소드가 정의되면 해당 scope에 static member로써 추가된다.<ul>
<li>메소드 안에서 메소드가 정의되면 메소드의 static member로써 추가된다.</li>
</ul>
</li>
<li>Exception 핸들링또한 Nested Func를 통해서 돌아간다.</li>
</ul>
<h1>다형성을 기본적으로 제공한다.</h1>
<h1>메소드의 sub nodes는 이름앞에 "_"를 붙이지 않더라도 private 접근제한자를 갖는다.</h1>
<ul>
<li>외부에서 호출할 수는 없다.</li>
<li>문법상에서 유일하게 사용되는 private다.</li>
</ul>
<h1>클래스 계층</h1>
<ul>
<li>Func는 Object와 동작이 상이하나 Node의 일종인 것은 맞다.</li>
<li>Func는 BlockExpr를 1개 소유한다.</li>
</ul>
<h1>특정한 인자타입리스트에 대해서 실행이 가능한지를 판별하는 메소드를 제공한다.</h1>
<ul>
<li>interpreter는 bind&amp;verify 에서 모호성 오류를 검증하기위해 인자리스트를 처리할 수 있는 곳인가를 반드시 짚고 넘어가야 하기 때문이다.</li>
<li>인자를 묵시적 변환을 거쳐서 처리가 가능한지를 반환해야 한다.</li>
<li>func을 갖는 obj는 소유한 func의 인자리스트 처리가능 여부와 함께, 처리 우선순위를 계산해서 가장 높은 순위 1개를 get()의 반환값으로 넘긴다. 모호성 오류가 발생한 경우에는 2개 이상이 나오게 된다.</li>
</ul>
<h1>method의 인자 deduction 우선순위</h1>
<ul>
<li>묵시적 변환이 일체 없이 타입이 정확히 일치하면 우선순위 0</li>
<li>변환이 불가능하면 우선순위 음수</li>
<li>묵시적 변환이 한번이라도 사용되었다면 우선순위 1이 된다.<ul>
<li>묵시적 변환이 몇번 발생했는지는 중요하지 않다.</li>
</ul>
</li>
</ul>
<h1>func에 thisptr도 함께 전달한다.</h1>
<ul>
<li>객체는 this를 수신하면 object scope을 this의 것으로 교체한다.</li>
</ul>
<h1>메소드ptr는 Ref에서 상속한 Delegator로 사용한다.</h1>
<ul>
<li>Ref는 type 이라는 별도의 Object로 verify를 한다.</li>
</ul>
<h1>각 함수 객체는 FuncType 이라는 type을 1개씩 갖는다.</h1>
<ul>
<li>함수는 FuncType 이라는 별도의 클래스로 verify를 한다.</li>
<li>FuncType은 하나의 Type으로는 불가능하고 인자와 반환형을 통해서 verify 한다.</li>
<li>반환형과 인자타입리스트가 동일하더라도 함수가 다르면 다른 FuncType 객체가 나온다.</li>
<li>native에서 템플릿을 사용하여 함수의 type을 가져올 수 없다. functype은 인스턴스별로 unique 하다.</li>
<li>FuncType.isSame(type)은 인자리스트와 반환형이 동일하면 true를 반환한다.</li>
</ul>
<h1>메소드 정의 문법</h1>
<ul>
<li>메소드 메소드명과 인자리스트를 함께 적는다. 인자리스트는 반드시 type declaration이 포함되어있어야 한다. <div class="fragment"><div class="line">def person</div>
<div class="line">    sayHello(name str, age int) res</div>
</div><!-- fragment --></li>
</ul>
<h1>기본값은 지원하지 않는다.</h1>
<ul>
<li>deduction이 복잡해서 그렇다. 나중에 지원할 수도 있다.</li>
<li>지원하게 된다면 아래와 같은 문법이 가능해진다. <div class="fragment"><div class="line">def person</div>
<div class="line">    sayHello(name := &quot;defaultName&quot;, age int := 5.5) res</div>
</div><!-- fragment --></li>
</ul>
<h1>메소드 식별문법</h1>
<ul>
<li>만약 메소드명 만으로도 식별이 가능하다면 인자리스트를 생략할 수 있다.</li>
</ul>
<div class="fragment"><div class="line">person.sayHello</div>
</div><!-- fragment --><ul>
<li>그 이외의 경우에는 인자리스트를 모두 적어줘야 한다. <div class="fragment"><div class="line">person.sayHello(a1 str, anyName int)</div>
</div><!-- fragment --></li>
<li>뒤에 반환형이 없다는 것으로 메소드의 정의와 구분한다.</li>
</ul>
<h2>빈 메소드일 경우는 void를 넣는다.</h2>
<div class="fragment"><div class="line">def person</div>
<div class="line">    sayHello() = null</div>
<div class="line">person.sayHello(void)</div>
</div><!-- fragment --><ul>
<li>void는 이 경우를 제외하고 void는 값으로 넘길 수 없다.</li>
</ul>
<h1>특수 메소드</h1>
<ul>
<li>앞에 @ prefix를 붙일 경우, 괄호를 붙이지 않아도 메소드로 인식한다.</li>
<li>@가 붙어도 되는 메소드명은 정해져있다.<ul>
<li>@ctor, @get, @set, @as</li>
</ul>
</li>
</ul>
<h1>비어있는 메소드</h1>
<ul>
<li>메소드가 비어있을 경우 기본값을 내보낸 것이다.</li>
</ul>
<h1>인터페이스 메소드</h1>
<ul>
<li>뒤에 = null을 적은 메소드는 호출이 불가능하다. 인터페이스로 사용된다.</li>
<li>overriding 혹은 type으로써 사용된다.</li>
<li>구현시 함수객체는 정상적으로 생성된다.</li>
<li>Null이 할당된것과 같다.</li>
<li>접근은 가능하다.</li>
<li>RTTI 메소드도 호출할 수 있다.</li>
<li>복제 혹은 메소드 호출은 안된다.</li>
</ul>
<div class="fragment"><div class="line">def person</div>
<div class="line">    someCallback() void</div>
<div class="line">        return</div>
<div class="line">    someCallback2() void // 위와 동일하다.</div>
<div class="line">    aInterface() void = null</div>
<div class="line"> </div>
<div class="line">person.someCallback2()</div>
<div class="line">person.aInterface() // err</div>
<div class="line">person.aInterface.name // ok</div>
</div><!-- fragment --><h1>메소드ptr를 정의하는 문법</h1>
<ul>
<li>인터페이스 메소드를 정의하는 것으로 메소드 ptr의 타입을 정의 하도록 한다.</li>
</ul>
<div class="fragment"><div class="line">def person</div>
<div class="line">    someCallback(p person) int = null</div>
<div class="line">    delayCall(fn someCallback) void</div>
<div class="line">        fn(this)</div>
<div class="line"> </div>
<div class="line">def app</div>
<div class="line">    _callback(p person) int</div>
<div class="line">        ret sys.csol.print(&quot;p.age=$p.age&quot;)</div>
<div class="line"> </div>
<div class="line">    main() void</div>
<div class="line">        person.delayCall(_callback)</div>
</div><!-- fragment --><h1>메소드를 ptr에 넘길 경우, 클로져 처럼 동작한다.</h1>
<ul>
<li>object scope가 캡처되서 FuncRef에 기록된다.</li>
</ul>
<h1>멤버함수 ptr 라는건 없다.</h1>
<ul>
<li>메소드를 갖는 클래스가 다르더라도 signature만 동일하다면 호출이 가능하다.</li>
</ul>
<div class="fragment"><div class="line">aka -&gt; sys.cons</div>
<div class="line"> </div>
<div class="line">def person</div>
<div class="line">    aka do() void = null -&gt; d</div>
<div class="line">    do(@d)</div>
<div class="line">        d.do()</div>
<div class="line"> </div>
<div class="line">def boy()</div>
<div class="line">    do() void: cons.out(&quot;shopping!&quot;)</div>
<div class="line"> </div>
<div class="line">def girl()</div>
<div class="line">    do() void: cons.out(&quot;exercise hardly!&quot;)</div>
<div class="line"> </div>
<div class="line">def app</div>
<div class="line">    main() void</div>
<div class="line">        person.do(boy.do)</div>
<div class="line">        person.do(girl.do)</div>
</div><!-- fragment --><h1>식별자 바인딩은 매번 get("identifier-name")을 넣음으로써 매번 검색한다.</h1>
<ul>
<li>optimization 과정이 끝날 경우, 이 과정은 상수타임에 끝나도록 한다.</li>
</ul>
<h1>메소드를 생성자처럼 사용하면 메소드가 생성되는 대신에 메소드호출이 된다.</h1>
<h1>메소드의 구현</h1>
<ul>
<li>객체와 달리 메소드는 scope이 항상 동적으로 구성된다.</li>
<li>func객체가 생성되는 시점에서 pack scope을 깔고 자신의 shared chain을 구성해놓지 않는다.</li>
<li>S(shared sub chain)과 NS(non shared sub array)가 obj 처럼 존재한다.</li>
<li>메소드 내에서 정의된 static 객체, origin 객체, 함수객체가 S chain에 generation 단계에서 추가된다.</li>
<li>로컬변수, 인자리스트는 NS에 정의된다.</li>
</ul>
<h1>메소드의 실행 알고리즘</h1>
<ul>
<li>thisobj와 인자리스트가 넘어온다.</li>
<li>thisobj로 objscope을 교체한다.<ul>
<li>thisobj는 pack scope까지 이미 가지고 있으므로 stackframe이 ptr를 1개 바꾸기만 하면 된다.</li>
<li>stackframe은 이미 있던 scope(= frame)을 stack에 넣고, 새로운 frame을 만들어 넘어온 thisobj의 scope으로 갱신한다.</li>
<li>이렇게 하는 이유는 외부에서도 stackframe의 목록을 접근할 수 있어야 하는 요구사항이 때문이다.</li>
<li>새로 추가된 frame의 chain에 func의 S를 push하고 NS를 deepcpy한 뒤 push한다.</li>
<li>메소드를 실행한다.</li>
<li>stackframe을 pop 한다.</li>
</ul>
</li>
</ul>
<h1>func도 origin 을 가지고 있다.</h1>
<ul>
<li>func 객체는 시스템내 유일하게 1개가 파서로부터 생성되서 origin객체에 붙어있게 된다.</li>
<li>func.origin에는 이 origin객체를 가리키게 된다.</li>
</ul>
<h1>func는 blockExpr가 아니며, blockExpr를 aggregation으로 가질 뿐이다.</h1>
<ul>
<li>blockExpr의 종류는 일반과 withBlockExpr 2 종류가 있다.</li>
</ul>
<h1>func과 obj는 같은 부모로 구성할 수 있다.</h1>
<ul>
<li>둘 모두 chain, S chain, NS array 3개가 필요하다.</li>
</ul>
<h1>func을 run() 하는 메소드는 func에만 정의되어 있다.</h1>
<ul>
<li>native world frx은 node 타입을 기반으로 동작하기때문에, 메소드 호출을 위해서는 캐스팅이 필요하다.</li>
</ul>
<h1>중첩메소드는 상위 메소드의 local scope을 공유한다.</h1>
<ul>
<li>중첩메소드의 정의 시점 보다 이후에 나오는 outer func의 로컬변수는 참조할 수 없다. <div class="fragment"><div class="line">def person</div>
<div class="line">    foo() void</div>
<div class="line">        age := 12</div>
<div class="line">        koo(val int) int</div>
<div class="line">            sum := val + age</div>
<div class="line">            return sum + nextYear // err: nextYear가 없다.</div>
<div class="line">        nextYear := 1</div>
<div class="line">        // koo의 정의가 여기에 있었다면 에러가 발생하지않는다.</div>
<div class="line">        koo(5)</div>
</div><!-- fragment --></li>
<li>명백히 말하면 실행시점에서의 바인딩을 체크해야 하나, 그렇게 되면 실행시점마다 바인딩을 체크해야 한다. if 등으로 branch 까지 고려하면 복잡도가 늘어나므로 제한을 두었다.</li>
</ul>
<h1>중첩메소드는 outer func의 sub를 모두 접근 가능하다.</h1>
<ul>
<li>메소드의 sub는 private로 되어있지만, 중첩메소드는 접근 할 수 있다.</li>
</ul>
<h1>중첩메소드의 실행 알고리즘</h1>
<ul>
<li>실행시 obj scope을 교체하지 않는다.<ul>
<li>따라서 실행시 outer func의 scope이 들어간 상태에서 실행이 된다. outer func의 local변수에 접근이 가능한 것이다.</li>
</ul>
</li>
<li>이미 있는 chain에 자신의 S, NS를 각각 얹는다.</li>
</ul>
<h1>중첩메소드에서 참조하는 상위 메소드의 local variable은 중첩메소드가 정의되는 코드보다 먼저 등장해야한다.</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
